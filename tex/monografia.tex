%% abntex2.latex, v<VERSION> dudektria
%% Copyright 2012-2015 by abnTeX2 group at http://abntex2.googlecode.com/ 
%%
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%%
%% This work has the LPPL maintenance status `maintained'.
%% 
%% The Current Maintainer of this work is Felipe Schneider.
%% Further information are available on http://abntex2.googlecode.com/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% USO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Este é um template para o pandoc compatível com abntex2
%
% É necessário chamar pandoc com pelo menos -V documentclass=abntex2 e
% --template=/caminho/absoluto/para/abntex2.latex
%
% Desta maneira, classes baseadas na abntex2 ainda podem ser usadas. O caminho
% absoluto é devido ao fato de o pandoc ter problemas com caminhos relativos.
%
% Todos os exemplos foram compilados com as seguintes opções (exceto quando
% eles mesmos dizem o contrário):
%
%   pandoc -V documentclass=abntex2 \
%          --template=/caminho/absoluto/para/abntex2.latex \
%          -SRs --normalize --filter=pandoc-citeproc \
%          -V lang=english,french,spanish,german,brazil -V papersize=a4paper \
%          -V fontsize=12pt -V classoption=twoside -V classoption=openright \
%          -V linkcolor=blue caminho/do/arquivo.md -o caminho/do/arquivo.pdf
%
% Os com _art.pdf no final receberam também -V classoption=article
% Trocando a extensão do arquivo final de .pdf para .latex gera-se o código
% fonte, para processamento adicional posterior
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% METADATA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% As seguintes metadatas relacionadas ao abntex2 estão disponíveis no template:
% - title:			título do trabalho (caso não haja capa será chamado
%					\maketitle)
% - date:			data
% - author:			autor(es) do trabalho
% - place:			local
% - institution:	instituição
% - preamble:		ver documentação do abntex2 (\preambulo{})
% - abstract:		texto do resumo
% - tags:			lista de palavras-chave (aparece se abstract for definido)
% - tagstitle:		nome para substituir "Palavras-chave" no texto
% - capa:			se true chama \imprimircapa
% - folhaderosto:	se true chama \imprimirfolhaderosto
% - tipotrabalho:	ver documentação do abntex2
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CITAÇÕES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% São feitas pelo pandoc-citeproc (chame pandoc --filter=pandoc-citeproc).
% Isto quer dizer que você precisa chamar
%
%   \postextual
%   # Referências
%
% ou algo semelhante no final do seu markdown. Para citar use as metadatas
% bibliography e csl como descrito na documentação do pandoc.
%
\documentclass[12pt,a4paper,openright,twoside,english,brazil,]{abntex2}	% Opções da classe do documento:
			% 	fontsize,lang,papersize,classoption
\usepackage[T1]{fontenc}
\usepackage{lmodern}	% Latin Modern
\usepackage{amssymb,amsmath}	% Símbolos matemáticos (Pandoc)
\usepackage{ifxetex,ifluatex}	% Testes de processadores (Pandoc)
\usepackage{fixltx2e} % provides \textsubscript
\usepackage{indentfirst}	% Indenta o primeiro parágrafo
\usepackage{color}	% Controle de cores
\usepackage{relsize}

\definecolor{blue}{RGB}{41,5,195}	% Altera o aspecto do azul
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}	% Adição de inputenc
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Daniel Q. Miranda},
            pdftitle={Monografia Preliminar - Implementação do Protocolo HTTP2 na linguagem Scala},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=blue,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{1.3cm}	% Tamanho dos parágrafos
\setlength{\parskip}{0.2cm}	% Espaçamento entre parágrafos
\setcounter{secnumdepth}{0}
\ifxetex
  \usepackage{polyglossia}
  \setmainlanguage{brazil}
\else
  \usepackage[]{babel}	% Adiciona a última língua de english,brazil
\fi

\titulo{Monografia Preliminar - Implementação do Protocolo HTTP2 na linguagem
Scala}	% Adicionando o título
\autor{Daniel Q. Miranda}	% Adicionando autor(es)
\orientador{Prof.~Dr.~Daniel Macêdo Batista}  % Adicionando orientadores(es)
\data{Outubro 2015}	% Adicionando a data
\local{São Paulo, Brasil}	% Adicionando o local
\instituicao{Instituto de Matemática e Estatística - Universidade de Sâo Paulo}	% Adicionando a instituição

\begin{document}
\imprimircapa	% Imprimindo a capa
\imprimirfolhaderosto	% Imprimindo a folha de rosto

\begin{resumo}
Resumo linha 1\\
Resumo linha 2   % Adicionando o resumo (Português)
\\
\vspace{\onelineskip}
\noindent\textbf{Palavras-chave}: feio, chato, bobo.  % Adicionando as palavras-chaves (Português)
\end{resumo}

\begin{resumo}[Abstract]
\begin{otherlanguage*}{english}
Abstract line 1\\
Abstract line 2   % Adicionando o resumo (Inglês)
\\
\vspace{\onelineskip}
\noindent\textbf{Keywords}: ugly, boring, fool.  % Adicionando as palavras-chaves (Inglês)
\end{otherlanguage*}
\end{resumo}

{
\hypersetup{linkcolor=black}
\setcounter{tocdepth}{3}
\noindent\tableofcontents* % Adicionando sumário
\cleardoublepage
}

\textual	% Início do texto convertido do arquivo original
\section{Introdução}\label{introduuxe7uxe3o}

O protocolo de comunicação de rede HTTP/2 foi definido e aceito pela
Internet Engineering Task Force (IETF) em 2015
(\href{https://tools.ietf.org/html/rfc7540}{RFC 7540}). Com o objetivo
de substituir o HTTP como alicerce da Internet, traz um mecanismo de
transmissão totalmente novo com semântica preservada, buscando melhorias
de aproveitamento de recursos, performance e extensibilidade

O HTTP/2 define uma representação binária, em contraste com a definição
textual do seu predecessor, e permite a coexistência de múltiplos fluxos
de dados simultâneos através de uma única conexão. Define um método de
compressão de \emph{Headers} eficiente e resistente a ataques contra
criptografia, e torna desnecessárias diversas otimizações inconvenientes
que hoje se fazem necessárias para acelerar o carregamento de páginas
Web.

Softwares clientes na Internet como browsers e utilitários de download
já implementam o novo protocolo. O suporte em servidores inicia-se mais
lentamente, devido a maior complexidade envolvida em sua implementação.
Mas dois dos mais utilizados servidores de código-livre, {[}Apache
HTTPD{]}{[}apache{]} e {[}nginx{]}{[}{]}, já fornecem versões
experimentais do HTTP/2 (em Outubro de 2015).

Este trabalho descreverá uma implementação do protocolo HTTP/2, com
facetas de cliente e servidor, na linguagem de programação orientada a
objetos e funcional \href{http://scala-lang.org}{Scala}, utilizando o
modelo de atores (Hewitt 1977) implementado pela plataforma
\href{http://akka.io}{Akka}. Esta combinação permite elegância e coesão
do código, através da composição de componentes independentes, estágios
de processamento compostos organicamente, e alta performance devido a
maturidade da máquina virtual do Java utilizada.

Denominar-se-a daqui para frente o protocolo original HTTP e suas
revisões até 1.1 como ``HTTP/1''. A versão 2 definida em 2015 será
mencionada como ``HTTP/2'', e aspectos comuns a ambas serão referidos
genericamente como ``HTTP''

\section{Motivação}\label{motivauxe7uxe3o}

\subsection{O protocolo HTTP/2}\label{o-protocolo-http2}

Como sucessor do HTTP/1, o HTTP/2 foi desenvolvido para atender a
diversos casos de uso de comunicação na Internet, dos quais um dos mais
utilizados é a visualização de documentos e aplicações na Web. Para
alcançar tais objetivos utiliza mecanismos mais complexos que a
comunicação textual delimitada por linhas da primeira versão.

\subsubsection{Formato Binário}\label{formato-binuxe1rio}

O HTTP define objetos a serem transmitidos como conjuntos de
\emph{headers}, parâmetros e informações de um \emph{pedido} ou
\emph{resposta} delimitados por linhas, seguidos de octetos de uma
mensagem. Este modelo é suficiente para o caso original de transmissão
de páginas Web simples, mas é falho para representar interações mais
complexas que uma única transmissão de mensagem simultânea.

O HTTP/2 substitui a representação textual por um conjunto de mensagens
de formato binario, que podem definir parâmetros de conexão, transmissão
de headers, corpo de mensagens, abertura de múltiplos canais, e ainda
requisição de pré-carregamento de recursos além do sujeito atual.

\subsubsection{Compressão de Headers}\label{compressuxe3o-de-headers}

O HTTP/2 define um sub-formato
(\href{https://http2.github.io/http2-spec/compression.html}{HPACK}) para
transmissão de headers de maneira eficiente, comprimindo-as através de
manutenção de tabelas de chaves e valores comuns, e aplicação de
Codificação de Huffman como compressão. Técnicas pré-existentes, como o
uso de algoritmos sobre a mensagem como um todo, são sujeitas a falhas
de segurança (CRIME (Kelsey 2002), BREACH (Prado, Harris, and Gluck
2013)), mas este esquema foi definido de maneira resistente a estes
ataques e que exclui conteúdos sensíveis da conversão.

\subsubsection{Multiplexação e controle de
fluxo}\label{multiplexauxe7uxe3o-e-controle-de-fluxo}

O HTTP/2 define um sistema de múltiplos fluxos de dados (\emph{streams})
simultâneos. Eles representam canais de comunicação independentes e
bidirecionais, pelos quais mensagens podem trafegar entre os
interlocutores. Transmissões de vários fluxos podem transitar em uma
única conexão TCP através da intercalação de \emph{frames} entre eles.

Fluxos podem ser criados e destruídos de maneira individual e (fix:
independente) do ciclo de vida da conexão como um todo. Cada um é
atribuído uma \emph{janela de controle de fluxo}, que pode ser usada por
um interlocutor para restringir a velocidade de transmissão de dados em
curso. Um remetente deve restringir suas transmissões caso a janela de
um dado fluxo esteja totalmente utilizada, permitindo, por exemplo, que
dispositivos com recursos escassos não sejam sobrecarregados.

Este mecanismo permite que diversos objetos sejam transmitidos
simultaneamente, como ocorre muito comummente em páginas Web complexas,
sem estressar a infraestrutura da camada de transmissão sobre a qual o
HTTP existe.

\subsubsection{Priorização}\label{priorizauxe7uxe3o}

É possível atribuir dependências e níveis de prioridades a fluxos
distintos, indicando maior importância ou urgência a mensagens neles
enviadas.

Fluxos subordinados só podem receber recursos caso seus superiores
estejam ociosos ou em espera. Num mesmo nível da hierarquia, recebem
recursos proporcionais a um valor inteiro atribuído a cada um,
representando uma fração do total disponível. (por exemplo, 3 fluxos de
prioridades 3, 5 e 10, respectivamente receberiam 3/18, 5/18 e 10/18 da
banda de transmissão disponível)

\section{Tecnologias utilizadas}\label{tecnologias-utilizadas}

\subsection{A Linguagem Scala}\label{a-linguagem-scala}

\href{}{Scala} é uma linguagem multi-paradigma, que tem como principal
característica a combinação da orientação a objetos, compatível com a
plataforma Java, e da programação funcional.

Possui um sistema de tipos poderoso, com funções de primeira-classes,
tipos parametrizados e inferência local, e permite expressar
sucintamente programas de diversos tipos.

Foi escolhida para elaboração desse trabalho devido a alta maturidade do
ecossistema Java e da plataforma Akka, seu alto poder expressivo e foco
em estruturas de dados imutáveis, concorrência e elegância.

\subsection{A Plataforma Akka}\label{a-plataforma-akka}

\href{}{Akka} é uma plataforma que implementa o modelo de atores para
criação de sistemas concorrentes, tolerantes a falhas e de alta
escalabilidade em Scala ou Java. Permite programar fluxos de dados de
maneira assíncrona e eficiente, incluindo servidores TCP como é
necessário para utilização do HTTP.

Atores comunicam-se somente através de passagem de mensagens discretas,
o que é conducente a diminuição de dependências e estado compartilhado,
e a modularização dos componentes do software.

\section{Implementação}\label{implementauxe7uxe3o}

TODO

\subsection{O paradigma funcional e
imutabilidade}\label{o-paradigma-funcional-e-imutabilidade}

TODO

\subsection{O modelo de Atores}\label{o-modelo-de-atores}

TODO

\subsection{Testes}\label{testes}

TODO

\subsubsection{Verificação de entradas e
saídas}\label{verificauxe7uxe3o-de-entradas-e-sauxeddas}

TODO

\subsubsection{Testes de integração com aplicações
reais}\label{testes-de-integrauxe7uxe3o-com-aplicauxe7uxf5es-reais}

TODO

\subsection{Compressão de headers
(HPACK)}\label{compressuxe3o-de-headers-hpack}

A transmissão de headers de mensagens no HTTP/2 é feita através de um
protocolo próprio chamado \href{}{HPACK}, criado especificamente para
este propósito. Como no HTTP/1, headers são uma série de chaves e
valores definidas por cadeias de caracteres, representando metadados de
uma mensagem, como o formato do conteúdo, localização, data de
modificação, informações dos interlocutores, etc.

Como o HTTP não define um mecanismo para preservação de estado
compartilhado entre múltiplas mensagens, headers são comummente
utilizadas para esse fim. Um dos mecanismos mais populares são os
\emph{Cookies}, também mapeamentos entre chaves e valores, que são
enviados por um remetente para que o destinatário possa o identificar,
reiniciar uma sessão anterior, ou reaver qualquer outro tipo de
informação. Sua funcionalidade os torna sensíveis a vazamento, já que
protegem acesso a sistemas de todos os tipos na Web.

A natureza repetitiva destes metadados faz com que sua compressão seja
muito vantajosa, especialmente para mensagens curtas, ou com metadados
semelhantes entre si. No HTTP/1, durante anos utilizaram-se algoritmos
de compressão aplicados sobre uma mensagem inteira, incluindo corpo e
headers, protegida sob um protocolo de confidencialidade como o TLS.
Descobriu-se, porém, que esse esquema é vulnerável a ataques que
recuperam gradativamente informações através da observação da eficiência
da codificação. (CRIME (Kelsey 2002), BREACH (Prado, Harris, and Gluck
2013)), e portanto essa prática é \emph{banida} no HTTP/2.

Substitui-na o HPACK, que comprime headers individualmente, através da
manutenção de uma tabela de cadeias comuns e previamente observadas em
uma conexão. Cadeias longas ou que não foram observadas anteriormente
são comprimidas através da Codificação de Huffman (Huffman 1952) com
símbolos estáticos, que não é sujeita a nenhuma ataque de correlação
conhecido. Remetentes podem especificar que certas chaves são sensíveis
e não devem ser comprimidas de nenhuma maneira (como por exemplo os já
mencionados cookies).

\subsubsection{Aplicação da Codificação de Huffman sem
árvores}\label{aplicauxe7uxe3o-da-codificauxe7uxe3o-de-huffman-sem-uxe1rvores}

O mapeamento estático de símbolos da Codificação de Huffman do HPACK
correlaciona octetos com códigos que variam entre 5 e 31 bits. Ao
contrário dos usos mais comuns desse algoritmo, onde o mapeamento é
construído à partir de cada mensagem a ser comprimida, a tabela é
pré-definida, igual para todas as mensagens, e de tamanho pequeno (256
entradas, suficientes para um octeto e um símbolo especial de fim de
mensagem).

Estas particularidades permitem que seja adotada uma implementação mais
simples e eficiente que a tradicional. Em vez de construir uma arvore de
prefixos com nós correspondentes a um bit, e processar a entrada
bit-a-bit, é possível particionar os códigos por seu tamanho, ler os
dados octeto-a-octeto, e comparar com a tabela aplicando-se uma máscara.

(falar O(n) vs O(log N), mas constante pequena))

\subsection{\texorpdfstring{Biblioteca de comunicação \emph{Akka
I/O}}{Biblioteca de comunicação Akka I/O}}\label{biblioteca-de-comunicauxe7uxe3o-akka-io}

TODO

\subsection{\texorpdfstring{Controle de fluxo de
\emph{streams}}{Controle de fluxo de streams}}\label{controle-de-fluxo-de-streams}

TODO

\subsection{Interface de
programação}\label{interface-de-programauxe7uxe3o}

TODO

\postextual

\hyperdef{}{references}{\label{references}}
\section*{Referências}\label{referuxeancias}
\addcontentsline{toc}{section}{Referências}

\hyperdef{}{ref-actor-hewitt}{\label{ref-actor-hewitt}}
Hewitt, Carl. 1977. ``Viewing Control Structures as Patterns of Passing
Messages.'' \emph{Artificial Intelligence} 8 (3): 323--64.
doi:\url{http://doi.org/http://dx.doi.org/10.1016/0004-3702(77)90033-9}.

\hyperdef{}{ref-huffman}{\label{ref-huffman}}
Huffman, D.A. 1952. ``A Method for the Construction of
Minimum-Redundancy Codes.'' \emph{Proceedings of the IRE} 40 (9):
1098--1101. doi:\url{http://doi.org/10.1109/JRPROC.1952.273898}.

\hyperdef{}{ref-raey}{\label{ref-raey}}
Kelsey, John. 2002. ``Compression and Information Leakage of
Plaintext.'' In \emph{Fast Software Encryption}, edited by Joan Daemen
and Vincent Rijmen, 2365:263--76. Lecture Notes in Computer Science.
Springer Berlin Heidelberg.
doi:\url{http://doi.org/10.1007/3-540-45661-9_21}.

\hyperdef{}{ref-pradossl}{\label{ref-pradossl}}
Prado, Angelo, Neal Harris, and Yoel Gluck. 2013. ``SSL, Gone in 30
Seconds.'' In \emph{Black Hat USA}.
\url{http://breachattack.com/resources/BREACH\%20-\%20BH\%202013\%20-\%20PRESENTATION.pdf}.	% No próprio texto é necessário invocar \postextual

\end{document}
