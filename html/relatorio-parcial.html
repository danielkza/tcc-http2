<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Daniel Q. Miranda">
  <title>Relatório Parcial - Implementação do Protocol HTTP2 na linguagem Scala</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
  <!--[if lt IE 9]>
    <script src="https://github.com/scottjehl/Respond/blob/master/src/respond.js"></script>
  <![endif]-->
  <style type="text/css">
  body {
    min-height: 2000px;
  }
  
  .navbar-static-top {
    margin-bottom: 19px;
  }
  </style>
</head>
<body>

<!-- Static navbar -->
<div class="navbar navbar-default navbar-static-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Daniel Q. Miranda - TCC 2015</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <!--<li><a href="estudo.html">Estudo Inicial</a></li>-->
        <li><a href="proposta.html">Proposta de trabalho</a></li>
        <li class="active"><a href="relatorio-parcial.html">Relatório Parcial</a></li>
        <li><a href="monografia.html">Monografia Preliminar</a></li>
      </ul>
    </div>
  </div>
</div>

<div class="container">
<header>
<h1 class="title">Relatório Parcial - Implementação do Protocol HTTP2 na linguagem Scala</h1>
<h2 class="author">Daniel Q. Miranda</h2>
<h2 class="author">Orientador: Prof. Dr. Daniel Macêdo Batista</h2>
</header>
<nav id="TOC">
<ul>
<li><a href="#proposta">Proposta</a></li>
<li><a href="#cronograma-previsto-inicialmente">Cronograma previsto inicialmente</a></li>
<li><a href="#progresso-atual">Progresso atual</a></li>
<li><a href="#plataforma-akka">Plataforma Akka</a></li>
<li><a href="#o-protocolo-http2">O protocolo HTTP/2</a><ul>
<li><a href="#utilizar-eficientemente-um-número-pequeno-menor-possível-de-conexões">Utilizar eficientemente um número pequeno (menor possível) de conexões</a></li>
<li><a href="#diminuir-o-uso-de-banda-em-geral">Diminuir o uso de banda em geral</a></li>
<li><a href="#melhorar-eficiência-de-aplicações-que-usam-o-http-como-a-web">Melhorar eficiência de aplicações que usam o HTTP, como a Web</a></li>
<li><a href="#manter-compatibilidade-bidirecional-entre-http1-e-http2">Manter compatibilidade &quot;bidirecional&quot; entre HTTP/1 e HTTP/2</a></li>
</ul></li>
<li><a href="#implementações-existentes-do-http2-e-outros-servidores-em-java">Implementações existentes do HTTP/2 e outros servidores em Java</a></li>
<li><a href="#decisões-de-design-e-escolhas-tomadas">Decisões de design e escolhas tomadas</a><ul>
<li><a href="#cronograma">Cronograma</a></li>
</ul></li>
</ul>
</nav>
<h1 id="proposta">Proposta</h1>
<p>Me proponho a implementar uma biblioteca e/ou servidor HTTP/2 na linguagem Scala. Preferencialmente buscarei trabalhar para que ela seja integrada ao projeto <a href="http://akka.io">Akka</a>, muito popular framework de concorrência e computação distribuída na JVM, que recentemente iniciou um projeto de implementação de HTTP combinando esforços de diversos outros projetos e frameworks de aplicações Web. Caso isso não seja possível, a desenvolverei de maneira independente.</p>
<h1 id="cronograma-previsto-inicialmente">Cronograma previsto inicialmente</h1>
<ul>
<li>Mar-Abr: Estudo preliminar, estudo do projeto Akka e conversa com desenvolvedores para verificar viabilidade de integração</li>
<li>Abr-Maio: Design inicial de arquitetura, planejamento, estudo do protocolo</li>
<li>Maio-Jul: Design de APIs, detalhamento da arquitetura, prototipação inicial</li>
<li>Jul-Out: Implementação de biblioteca já funcional, incluindo maior partes das features possível:
<ul>
<li>Múltiplos streams (multiplexing)<br />
</li>
<li>Compressão de Headers<br />
</li>
<li><em>Server Push</em><br />
</li>
<li>HTTP2c (TLS)<br />
</li>
</ul></li>
<li>Out-Nov: Otimizações de performances, testes e comparações com outras implementações, elaboração de estudos de arquitetura,</li>
</ul>
<h1 id="progresso-atual">Progresso atual</h1>
<p>Até o presente momento a maior parte do progresso constituiu em compreender e avaliar:</p>
<ul>
<li>O protocolo HTTP/2<br />
</li>
<li>Implementações existentes do HTTP/2 em diversas linguagens<br />
</li>
<li>Implementações de outros servidores HTTP em Java<br />
</li>
<li>O ecossistema Scala e aplicação possível do resultado pela comunidade</li>
</ul>
<h1 id="plataforma-akka">Plataforma Akka</h1>
<p>O plano inicial era trabalhar dentro da plataforma Akka, já muito adotada para concorrência em Java e Scala, e que parece estar, com sucesso, iniciando um processo de unificação de bibliotecas de comunicação na JVM.</p>
<p>O contato inicial do projeto foi recebido até com interesse, mas os desenvolvedores manifestaram falta de recursos e/ou tempo para *** a iniciativa. O Akka, assim como diversos outros grandes projetos em Scala, vem sendo financiado pela empresa <a href="http://typesafe.com">Typesafe</a>, e a maioria dos contribuidores de grande-escala são seus empregados, com objetivos e planos pré-existentes e nem sempre flexíveis.</p>
<p>Decidi então trabalhar por contra própria, tomando a biblioteca HTTP do Akka apenas como inspiração. Porém, ainda cogito utilizar a biblioteca homônima ao projeto, que lida principalmente com concorrência através do modelo de atores (mais sobre isso segue nas próximas seções), entrada e saída a nível de arquivos e sockets, dentre outros.</p>
<h1 id="o-protocolo-http2">O protocolo HTTP/2</h1>
<p>A nova versão do protocolo HTTP (<a href="(https://tools.ietf.org/html/rfc7540">HTTP/2</a>) adiciona um certo nível de complexidade ao original para alcançar diversos objetivos, visando modernizar o protocolo para que ele continue eficiente nas décadas que seguirão.</p>
<p>Alguns exemplos destes objetivos, com seus correspondentes mecanismos, são:</p>
<h3 id="utilizar-eficientemente-um-número-pequeno-menor-possível-de-conexões">Utilizar eficientemente um número pequeno (menor possível) de conexões</h3>
<p>O protocolo HTTP/2 permite a existência de múltiplos <em>streams</em> de dados, tanto cliente-servidor como na direção oposta, para aproveitar ao máximo uma única conexão TCP. Isso permite que, por exemplo, diversos recursos sejam carregadas simultaneamente, que ações de um usuário em um aplicativo Web sejam enviadas sem espera, ou que um modo de uso com troca de informações contínua seja possível (que hoje, por exemplo, é comummente implementado em browsers por um segundo protocolo, o <a href="https://www.websocket.org/">WebSocket</a>).</p>
<h3 id="diminuir-o-uso-de-banda-em-geral">Diminuir o uso de banda em geral</h3>
<p>Mecanismos de compressão são suportados universalmente pelo HTTP/1 há mais de uma década, mas em múltiplos casos fraquezas de segurança (CRIME <span class="citation" data-cites="raey">(Kelsey 2002)</span>, BREACH <span class="citation" data-cites="pradossl">(Prado, Harris, and Gluck 2013)</span>) foram descobertas durante seu uso, causadas pelo gradual &quot;vazamento&quot; de informações sobre padrões dos dados ou meta-dados transmitidos. O HTTP/2 visa melhorar significativamente esta situação introduzindo um mecanismo próprio de compressão de headers, eficiente e resistente a esses vazamentos, chamado <a href="https://http2.github.io/http2-spec/compression.html">HPACK</a>.</p>
<h3 id="melhorar-eficiência-de-aplicações-que-usam-o-http-como-a-web">Melhorar eficiência de aplicações que usam o HTTP, como a Web</h3>
<p>O mecanismo de &quot;Server Push&quot;, onde um servidor pode preventivamente recomendar que um cliente faça uma requisição pode acelerar significativamente a visualização de páginas Web em geral. Também tem potencial benefício para o uso do HTTP como API (através de padrões como REST e SOAP), permitindo o paginamento de recursos de maneira limpa e eficiente.</p>
<h3 id="manter-compatibilidade-bidirecional-entre-http1-e-http2">Manter compatibilidade &quot;bidirecional&quot; entre HTTP/1 e HTTP/2</h3>
<p>Múltiplos mecanismos de negociação foram especificados, para permitir que:</p>
<ul>
<li>Clientes pré-existentes se mantenham funcionando sem perda de funcionalidade</li>
<li>Clientes novos possam se conectar de maneira genérica a um servidor, e utilizar o HTTP/2 se possível</li>
<li>Seja possível identificar se um servidor é compatível com HTTP/2 sem overhead.</li>
</ul>
<p>Os principais escolhidos e especificados no protocolo são:</p>
<ul>
<li>Negociação de upgrade: uma conexão HTTP/1 é iniciada, com um conjunto de headers informando a compatibilidade com HTTP/2. Isso permite conexão universal, aceita tanto por HTTP/1 e HTTP/2</li>
<li>Negociação de protocolo de aplicação através do TLS, quando em uso: o protocolo Transport Layer Security tem um mecanismo interno de negociação, que pode ser usado para selecionar HTTP/2 caso possível</li>
<li>Conexão direta através da versão 2, que tem um preâmbulo de conexão próprio, facilmente distinguível do HTTP/1</li>
</ul>
<h1 id="implementações-existentes-do-http2-e-outros-servidores-em-java">Implementações existentes do HTTP/2 e outros servidores em Java</h1>
<p>As principais implementações no ecossistema Java vem de dois projetos já muito estabelecidos: <a href="http://eclipse.org/jetty">Jetty</a> (do projeto Eclipse) e <a href="http://netty.io">Netty</a>. Ambas tem alto foco em performance e qualidade em geral, e tem grandes gamas de contribuidores e suporte.</p>
<p>Após o início do projeto, descobri a existência do projeto <a href="https://github.com/http4s/blaze">http4s-blaze</a> em Scala, com objetivos similares aos meus, que implementa um servidor HTTP/2 já na linguagem Scala. Teria sido interessante saber de sua existência de antemão, mas não vejo um problema: o objetivo principal do trabalho é o aprendizado e a experiência. Minha implementação pode seguir escolhas diferentes de arquitetura, prioridades, etc.</p>
<h1 id="decisões-de-design-e-escolhas-tomadas">Decisões de design e escolhas tomadas</h1>
<p>Embora infelizmente ainda tenha produzido pouco código, não suficiente para um protótipo, já tenho decididas diversas escolhas de modo de trabalho, arquitetura, objetivos, etc.</p>
<ul>
<li>Sistema de build: <a href="http://scala-sbt.org/">SBT</a></li>
<li>Biblioteca de I/O: <a href="http://doc.akka.io/docs/akka/current/scala/io.html">Akka I/O</a></li>
<li>Buscar ao máximo implementar, sempre que possível, todo o servidor utilizando estruturas de dados imutáveis, programação funcional e composição de componentes independentes. Este paradigma é fortemente suportado pela linguagem Scala, assim como a biblioteca Akka I/O, e não necessariamente incorre em perda de eficiência com o devido cuidado.</li>
<li>Focar em simplicidade e elegância arquitetural e correção em vez de performance. Devido ao tempo de trabalho e recursos, é incrivelmente difícil competir com projetos com vários contribuidores, empresas em seu suporte, poder computacional, etc. no quesito performance</li>
<li>Utilizar um design baseado em &quot;pipeline&quot;, com os diversos estágios de um request sendo tratados independentemente por componentes distintos</li>
</ul>
<h2 id="cronograma">Cronograma</h2>
<p>O plano do cronograma inicial segue mantido: o trabalho até outubro/novembro consistirá em implementar o máximo possível do protocolo em um servidor simples, mas funcional. Para alcançar esse objetivo, serão necessárias algumas adaptações, como:</p>
<ul>
<li>Se limitar a um ou o menor número possível de métodos de negociação<br />
</li>
<li>Focar inicialmente na comunicação básica, codificação, decodificação e tratamento de headers, assim como funcionamento com streams únicos (mas bidirecionais)</li>
<li>Focar inicialmente na implementação sem TLS (em <em>plain-text</em>)</li>
</ul>
<div id="refs" class="references">
<div id="ref-raey">
<p>Kelsey, John. 2002. “Compression and Information Leakage of Plaintext.” In <em>Fast Software Encryption</em>, edited by Joan Daemen and Vincent Rijmen, 2365:263–76. Lecture Notes in Computer Science. Springer Berlin Heidelberg. doi:<a href="http://doi.org/10.1007/3-540-45661-9_21">10.1007/3-540-45661-9_21</a>.</p>
</div>
<div id="ref-pradossl">
<p>Prado, Angelo, Neal Harris, and Yoel Gluck. 2013. “SSL, Gone in 30 Seconds.” In <em>Black Hat USA</em>. <a href="http://breachattack.com/resources/BREACH%20-%20BH%202013%20-%20PRESENTATION.pdf">http://breachattack.com/resources/BREACH%20-%20BH%202013%20-%20PRESENTATION.pdf</a>.</p>
</div>
</div>
</div>


</body>
</html>
