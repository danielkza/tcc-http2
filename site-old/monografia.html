<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Daniel Q. Miranda - TCC - 2015 - IME-USP</title>

    <!-- Bootstrap core CSS -->
    <link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="navbar-static-top.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <style>
    html, body, iframe, .container { height: 100%; }
    </style>
  </head>

  <body>

    <!-- Static navbar -->
    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Daniel Q. Miranda - TCC 2015</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <!--<li><a href="estudo.html">Estudo Inicial</a></li>-->
            <li><a href="proposta.html">Proposta de trabalho</a></li>
            <li class="active"><a href="monografia.html">Monografia Preliminar</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <div class="container">
<h1 id="resumo">Resumo</h1>
<p>TODO</p>
<h1 id="índice">Índice</h1>
<ol style="list-style-type: decimal">
<li>Introdução<br /></li>
<li>Motivação
<ol style="list-style-type: decimal">
<li>O protocolo HTTP/2
<ol style="list-style-type: decimal">
<li>Introdução</li>
<li>Objetivos</li>
<li>Mecanismos
<ol style="list-style-type: decimal">
<li>Formato binário</li>
<li>Compressão de Headers (HPACK)</li>
<li>Multiplexação e controle de fluxo</li>
<li>Priorização</li>
</ol></li>
</ol></li>
<li>Tecnologias utilizadas
<ol style="list-style-type: decimal">
<li>Linguagem Scala</li>
<li>A plataforma Akka</li>
</ol></li>
</ol></li>
<li>Implementação
<ol style="list-style-type: decimal">
<li>Paradigma funcional e imutabilidade</li>
<li>O modelo de Atores</li>
<li>Testes
<ol style="list-style-type: decimal">
<li>Verificação de entradas e saídas</li>
<li>Testes de integração com aplicações reais</li>
</ol></li>
<li>Compressão de headers (HPACK)
<ol style="list-style-type: decimal">
<li>Aplicação da codificação de Huffman sem árvores</li>
</ol></li>
<li>Biblioteca de comunicação <em>Akka I/O</em></li>
<li>Controle de fluxo de <em>streams</em></li>
<li>Interface de programação</li>
<li></li>
</ol></li>
</ol>
<h1 id="introdução">Introdução</h1>
<p>O protocolo de comunicação de rede HTTP/2 foi definido e aceito pela Internet Engineering Task Force (IETF) em 2015 (<a href="https://tools.ietf.org/html/rfc7540">RFC 7540</a>). Com o objetivo de substituir o HTTP como alicerce da Internet, traz um mecanismo de transmissão totalmente novo com semântica preservada, buscando melhorias de aproveitamento de recursos, performance e extensibilidade</p>
<p>O HTTP/2 define uma representação binária, em contraste com a definição textual do seu predecessor, e permite a coexistência de múltiplos fluxos de dados simultâneos através de uma única conexão. Define um método de compressão de <em>Headers</em> eficiente e resistente a ataques contra criptografia, e torna desnecessárias diversas otimizações inconvenientes que hoje se fazem necessárias para acelerar o carregamento de páginas Web.</p>
<p>Softwares clientes na Internet como browsers e utilitários de download já implementam o novo protocolo. O suporte em servidores inicia-se mais lentamente, devido a maior complexidade envolvida em sua implementação. Mas dois dos mais utilizados servidores de código-livre, [Apache HTTPD][apache] e [nginx][], já fornecem versões experimentais do HTTP/2 (em Outubro de 2015).</p>
<p>Este trabalho descreverá uma implementação do protocolo HTTP/2, com facetas de cliente e servidor, na linguagem de programação orientada a objetos e funcional <a href="http://scala-lang.org">Scala</a>, utilizando o modelo de atores <span class="citation">(Hewitt 1977)</span> implementado pela plataforma <a href="http://akka.io">Akka</a>. Esta combinação permite elegância e coesão do código, através da composição de componentes independentes, estágios de processamento compostos organicamente, e alta performance devido a maturidade da máquina virtual do Java utilizada.</p>
<p>Denominar-se-a daqui para frente o protocolo original HTTP e suas revisões até 1.1 como &quot;HTTP/1&quot;. A versão 2 definida em 2015 será mencionada como &quot;HTTP/2&quot;, e aspectos comuns a ambas serão referidos genericamente como &quot;HTTP&quot;</p>
<h1 id="motivação">Motivação</h1>
<h2 id="o-protocolo-http2">O protocolo HTTP/2</h2>
<p>Como sucessor do HTTP/1, o HTTP/2 foi desenvolvido para atender a diversos casos de uso de comunicação na Internet, dos quais um dos mais utilizados é a visualização de documentos e aplicações na Web. Para alcançar tais objetivos utiliza mecanismos mais complexos que a comunicação textual delimitada por linhas da primeira versão.</p>
<h3 id="formato-binário">Formato Binário</h3>
<p>O HTTP define objetos a serem transmitidos como conjuntos de <em>headers</em>, parâmetros e informações de um <em>pedido</em> ou <em>resposta</em> delimitados por linhas, seguidos de octetos de uma mensagem. Este modelo é suficiente para o caso original de transmissão de páginas Web simples, mas é falho para representar interações mais complexas que uma única transmissão de mensagem simultânea.</p>
<p>O HTTP/2 substitui a representação textual por um conjunto de mensagens de formato binario, que podem definir parâmetros de conexão, transmissão de headers, corpo de mensagens, abertura de múltiplos canais, e ainda requisição de pré-carregamento de recursos além do sujeito atual.</p>
<h3 id="compressão-de-headers">Compressão de Headers</h3>
<p>O HTTP/2 define um sub-formato (<a href="https://http2.github.io/http2-spec/compression.html">HPACK</a>) para transmissão de headers de maneira eficiente, comprimindo-as através de manutenção de tabelas de chaves e valores comuns, e aplicação de Codificação de Huffman como compressão. Técnicas pré-existentes, como o uso de algoritmos sobre a mensagem como um todo, são sujeitas a falhas de segurança (CRIME <span class="citation">(Kelsey 2002)</span>, BREACH <span class="citation">(Prado, Harris, and Gluck 2013)</span>), mas este esquema foi definido de maneira resistente a estes ataques e que exclui conteúdos sensíveis da conversão.</p>
<h3 id="multiplexação-e-controle-de-fluxo">Multiplexação e controle de fluxo</h3>
<p>O HTTP/2 define um sistema de múltiplos fluxos de dados (<em>streams</em>) simultâneos. Eles representam canais de comunicação independentes e bidirecionais, pelos quais mensagens podem trafegar entre os interlocutores. Transmissões de vários fluxos podem transitar em uma única conexão TCP através da intercalação de <em>frames</em> entre eles.</p>
<p>Fluxos podem ser criados e destruídos de maneira individual e (fix: independente) do ciclo de vida da conexão como um todo. Cada um é atribuído uma <em>janela de controle de fluxo</em>, que pode ser usada por um interlocutor para restringir a velocidade de transmissão de dados em curso. Um remetente deve restringir suas transmissões caso a janela de um dado fluxo esteja totalmente utilizada, permitindo, por exemplo, que dispositivos com recursos escassos não sejam sobrecarregados.</p>
<p>Este mecanismo permite que diversos objetos sejam transmitidos simultaneamente, como ocorre muito comummente em páginas Web complexas, sem estressar a infraestrutura da camada de transmissão sobre a qual o HTTP existe.</p>
<h3 id="priorização">Priorização</h3>
<p>É possível atribuir dependências e níveis de prioridades a fluxos distintos, indicando maior importância ou urgência a mensagens neles enviadas.</p>
<p>Fluxos subordinados só podem receber recursos caso seus superiores estejam ociosos ou em espera. Num mesmo nível da hierarquia, recebem recursos proporcionais a um valor inteiro atribuído a cada um, representando uma fração do total disponível. (por exemplo, 3 fluxos de prioridades 3, 5 e 10, respectivamente receberiam 3/18, 5/18 e 10/18 da banda de transmissão disponível)</p>
<h1 id="tecnologias-utilizadas">Tecnologias utilizadas</h1>
<h2 id="a-linguagem-scala">A Linguagem Scala</h2>
<p><a href="">Scala</a> é uma linguagem multi-paradigma, que tem como principal característica a combinação da orientação a objetos, compatível com a plataforma Java, e da programação funcional.</p>
<p>Possui um sistema de tipos poderoso, com funções de primeira-classes, tipos parametrizados e inferência local, e permite expressar sucintamente programas de diversos tipos.</p>
<p>Foi escolhida para elaboração desse trabalho devido a alta maturidade do ecossistema Java e da plataforma Akka, seu alto poder expressivo e foco em estruturas de dados imutáveis, concorrência e elegância.</p>
<h2 id="a-plataforma-akka">A Plataforma Akka</h2>
<p><a href="">Akka</a> é uma plataforma que implementa o modelo de atores para criação de sistemas concorrentes, tolerantes a falhas e de alta escalabilidade em Scala ou Java. Permite programar fluxos de dados de maneira assíncrona e eficiente, incluindo servidores TCP como é necessário para utilização do HTTP.</p>
<p>Atores comunicam-se somente através de passagem de mensagens discretas, o que é conducente a diminuição de dependências e estado compartilhado, e a modularização dos componentes do software.</p>
<h1 id="implementação">Implementação</h1>
<p>TODO</p>
<h2 id="o-paradigma-funcional-e-imutabilidade">O paradigma funcional e imutabilidade</h2>
<p>TODO</p>
<h2 id="o-modelo-de-atores">O modelo de Atores</h2>
<p>TODO</p>
<h2 id="testes">Testes</h2>
<p>TODO</p>
<h3 id="verificação-de-entradas-e-saídas">Verificação de entradas e saídas</h3>
<p>TODO</p>
<h3 id="testes-de-integração-com-aplicações-reais">Testes de integração com aplicações reais</h3>
<p>TODO</p>
<h2 id="compressão-de-headers-hpack">Compressão de headers (HPACK)</h2>
<p>A transmissão de headers de mensagens no HTTP/2 é feita através de um protocolo próprio chamado <a href="">HPACK</a>, criado especificamente para este propósito. Como no HTTP/1, headers são uma série de chaves e valores definidas por cadeias de caracteres, representando metadados de uma mensagem, como o formato do conteúdo, localização, data de modificação, informações dos interlocutores, etc.</p>
<p>Como o HTTP não define um mecanismo para preservação de estado compartilhado entre múltiplas mensagens, headers são comummente utilizadas para esse fim. Um dos mecanismos mais populares são os <em>Cookies</em>, também mapeamentos entre chaves e valores, que são enviados por um remetente para que o destinatário possa o identificar, reiniciar uma sessão anterior, ou reaver qualquer outro tipo de informação. Sua funcionalidade os torna sensíveis a vazamento, já que protegem acesso a sistemas de todos os tipos na Web.</p>
<p>A natureza repetitiva destes metadados faz com que sua compressão seja muito vantajosa, especialmente para mensagens curtas, ou com metadados semelhantes entre si. No HTTP/1, durante anos utilizaram-se algoritmos de compressão aplicados sobre uma mensagem inteira, incluindo corpo e headers, protegida sob um protocolo de confidencialidade como o TLS. Descobriu-se, porém, que esse esquema é vulnerável a ataques que recuperam gradativamente informações através da observação da eficiência da codificação. (CRIME <span class="citation">(Kelsey 2002)</span>, BREACH <span class="citation">(Prado, Harris, and Gluck 2013)</span>), e portanto essa prática é <em>banida</em> no HTTP/2.</p>
<p>Substitui-na o HPACK, que comprime headers individualmente, através da manutenção de uma tabela de cadeias comuns e previamente observadas em uma conexão. Cadeias longas ou que não foram observadas anteriormente são comprimidas através da Codificação de Huffman <span class="citation">(Huffman 1952)</span> com símbolos estáticos, que não é sujeita a nenhuma ataque de correlação conhecido. Remetentes podem especificar que certas chaves são sensíveis e não devem ser comprimidas de nenhuma maneira (como por exemplo os já mencionados cookies).</p>
<h3 id="aplicação-da-codificação-de-huffman-sem-árvores">Aplicação da Codificação de Huffman sem árvores</h3>
<p>O mapeamento estático de símbolos da Codificação de Huffman do HPACK correlaciona octetos com códigos que variam entre 5 e 31 bits. Ao contrário dos usos mais comuns desse algoritmo, onde o mapeamento é construído à partir de cada mensagem a ser comprimida, a tabela é pré-definida, igual para todas as mensagens, e de tamanho pequeno (256 entradas, suficientes para um octeto e um símbolo especial de fim de mensagem).</p>
<p>Estas particularidades permitem que seja adotada uma implementação mais simples e eficiente que a tradicional. Em vez de construir uma arvore de prefixos com nós correspondentes a um bit, e processar a entrada bit-a-bit, é possível particionar os códigos por seu tamanho, ler os dados octeto-a-octeto, e comparar com a tabela aplicando-se uma máscara.</p>
<p>(falar O(n) vs O(log N), mas constante pequena))</p>
<h2 id="biblioteca-de-comunicação-akka-io">Biblioteca de comunicação <em>Akka I/O</em></h2>
<p>TODO</p>
<h2 id="controle-de-fluxo-de-streams">Controle de fluxo de <em>streams</em></h2>
<p>TODO</p>
<h2 id="interface-de-programação">Interface de programação</h2>
<p>TODO</p>
<hr />
<div class="references">
<p>Hewitt, Carl. 1977. “Viewing Control Structures as Patterns of Passing Messages.” <em>Artificial Intelligence</em> 8 (3): 323–64. doi:<a href="http://dx.doi.org/http://dx.doi.org/10.1016/0004-3702(77)90033-9">http://dx.doi.org/10.1016/0004-3702(77)90033-9</a>.</p>
<p>Huffman, D.A. 1952. “A Method for the Construction of Minimum-Redundancy Codes.” <em>Proceedings of the IRE</em> 40 (9): 1098–1101. doi:<a href="http://dx.doi.org/10.1109/JRPROC.1952.273898">10.1109/JRPROC.1952.273898</a>.</p>
<p>Kelsey, John. 2002. “Compression and Information Leakage of Plaintext.” In <em>Fast Software Encryption</em>, edited by Joan Daemen and Vincent Rijmen, 2365:263–76. Lecture Notes in Computer Science. Springer Berlin Heidelberg. doi:<a href="http://dx.doi.org/10.1007/3-540-45661-9_21">10.1007/3-540-45661-9_21</a>.</p>
<p>Prado, Angelo, Neal Harris, and Yoel Gluck. 2013. “SSL, GONE iN 30 SECONDS.” In <em>Black Hat USA 2013</em>. <a href="http://breachattack.com/resources/BREACH%20-%20BH%202013%20-%20PRESENTATION.pdf">http://breachattack.com/resources/BREACH%20-%20BH%202013%20-%20PRESENTATION.pdf</a>.</p>
</div>

    </div>
</body>
</html>
